{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { noChange } from 'lit';\nimport { Directive, directive, PartType } from 'lit/directive.js';\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nvar State;\n(function (State) {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"INACTIVE\"] = 0] = \"INACTIVE\";\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: beginPress(); transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: beginPress(); transition to `HOLDING`.\n   */\n  State[State[\"TOUCH_DELAY\"] = 1] = \"TOUCH_DELAY\";\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  State[State[\"HOLDING\"] = 2] = \"HOLDING\";\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click endPress(); transition to `INACTIVE`.\n   */\n  State[State[\"WAITING_FOR_CLICK\"] = 3] = \"WAITING_FOR_CLICK\";\n})(State || (State = {}));\nclass RippleDirective extends Directive {\n  constructor(partInfo) {\n    super(partInfo);\n    this.rippleGetter = async () => null;\n    this.state = State.INACTIVE;\n    this.checkBoundsAfterContextMenu = false;\n    this.rippleStartEvent = null;\n    this.touchTimer = null;\n    this.clickTimer = null;\n    if (partInfo.type !== PartType.ELEMENT) {\n      throw new Error('The `ripple` directive must be used on an element');\n    }\n  }\n  render(ripple) {\n    return noChange;\n  }\n  // Use EventListenerObject::handleEvent interface to handle events without\n  // generating bound event handlers\n  async handleEvent(event) {\n    const ripple = await this.rippleGetter();\n    if (!ripple) {\n      return;\n    }\n    switch (event.type) {\n      case 'click':\n        this.click(ripple);\n        break;\n      case 'contextmenu':\n        this.contextMenu(ripple);\n        break;\n      case 'pointercancel':\n        this.pointerCancel(ripple, event);\n        break;\n      case 'pointerdown':\n        this.pointerDown(ripple, event);\n        break;\n      case 'pointerenter':\n        this.pointerEnter(ripple, event);\n        break;\n      case 'pointerleave':\n        this.pointerLeave(ripple, event);\n        break;\n      case 'pointerup':\n        this.pointerUp(ripple, event);\n        break;\n      default:\n        break;\n    }\n  }\n  update(part, _ref) {\n    let [ripple] = _ref;\n    if (!this.element) {\n      // NOTE: addEventListener typing needs to be used with HTMLElements or a\n      // subclass\n      this.element = part.element;\n      this.element.addEventListener('click', this);\n      this.element.addEventListener('contextmenu', this);\n      this.element.addEventListener('pointercancel', this);\n      this.element.addEventListener('pointerdown', this);\n      this.element.addEventListener('pointerenter', this);\n      this.element.addEventListener('pointerleave', this);\n      this.element.addEventListener('pointerup', this);\n    }\n    // Normalize given ripple accessor\n    this.rippleGetter = typeof ripple === 'function' ? ripple : () => ripple;\n    return noChange;\n  }\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  shouldReactToEvent(ripple, ev) {\n    let hovering = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    const enabled = !ripple.disabled;\n    const isPrimaryPointer = ev.isPrimary;\n    const isInteractionPointer = this.rippleStartEvent === null || this.rippleStartEvent.pointerId === ev.pointerId;\n    const isPrimaryButton = ev.buttons === 1;\n    return enabled && isPrimaryPointer && isInteractionPointer && (this.isTouch(ev) || isPrimaryButton || hovering);\n  }\n  isTouch(_ref2) {\n    let {\n      pointerType\n    } = _ref2;\n    return pointerType === 'touch';\n  }\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  inBounds(_ref3) {\n    let {\n      x,\n      y\n    } = _ref3;\n    const {\n      top,\n      left,\n      bottom,\n      right\n    } = this.element.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n  beginPress(ripple) {\n    ripple.beginPress(this.rippleStartEvent);\n  }\n  endPress(ripple) {\n    ripple.endPress();\n    this.state = State.INACTIVE;\n    this.rippleStartEvent = null;\n    if (this.touchTimer) {\n      clearTimeout(this.touchTimer);\n      this.touchTimer = null;\n    }\n    if (this.clickTimer) {\n      clearTimeout(this.clickTimer);\n      this.clickTimer = null;\n    }\n  }\n  waitForTouchHold() {\n    if (this.touchTimer !== null) {\n      clearTimeout(this.touchTimer);\n    }\n    this.state = State.TOUCH_DELAY;\n    this.touchTimer = setTimeout(async () => {\n      const ripple = await this.rippleGetter();\n      if (ripple === null || this.state !== State.TOUCH_DELAY) {\n        return;\n      }\n      this.state = State.HOLDING;\n      this.beginPress(ripple);\n    }, TOUCH_DELAY_MS);\n  }\n  click(ripple) {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (ripple.disabled) {\n      return;\n    }\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPress(ripple);\n    } else if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.beginPress(ripple);\n      this.endPress(ripple);\n    }\n  }\n  contextMenu(ripple) {\n    if (!ripple.disabled) {\n      this.checkBoundsAfterContextMenu = true;\n      this.endPress(ripple);\n    }\n  }\n  pointerDown(ripple, ev) {\n    if (!this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    this.rippleStartEvent = ev;\n    if (this.isTouch(ev)) {\n      // after a longpress contextmenu event, an extra `pointerdown` can be\n      // dispatched to the pressed element. Check that the down is within\n      // bounds of the element in this case.\n      if (this.checkBoundsAfterContextMenu && !this.inBounds(ev)) {\n        return;\n      }\n      this.checkBoundsAfterContextMenu = false;\n      this.waitForTouchHold();\n    } else {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n  pointerUp(ripple, ev) {\n    if (!this.isTouch(ev) || !this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n    } else if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n  pointerCancel(ripple, ev) {\n    if (this.shouldReactToEvent(ripple, ev)) {\n      this.endPress(ripple);\n    }\n  }\n  pointerEnter(ripple, ev) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.beginHover(ev);\n    }\n  }\n  pointerLeave(ripple, ev) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.endHover();\n      // release a held mouse or pen press that moves outside the element\n      if (!this.isTouch(ev) && this.state !== State.INACTIVE) {\n        this.endPress(ripple);\n      }\n    }\n  }\n}\n/**\n * Connects a Ripple element to a node that drives the interaction\n *\n * @param rippleGetter A function that returns an `md-ripple` element\n * @param simulateKeyboardClick For elements that do not issue a click on\n *     keyboard interaction, pass `true` to enable press animations on Enter or\n *     Spacebar\n */\nexport const ripple = directive(RippleDirective);","map":{"version":3,"mappings":"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","names":["noChange","Directive","directive","PartType","TOUCH_DELAY_MS","State","RippleDirective","constructor","partInfo","INACTIVE","type","ELEMENT","Error","render","ripple","handleEvent","event","rippleGetter","click","contextMenu","pointerCancel","pointerDown","pointerEnter","pointerLeave","pointerUp","update","part","element","addEventListener","shouldReactToEvent","ev","hovering","enabled","disabled","isPrimaryPointer","isPrimary","isInteractionPointer","rippleStartEvent","pointerId","isPrimaryButton","buttons","isTouch","pointerType","inBounds","x","y","top","left","bottom","right","getBoundingClientRect","beginPress","endPress","state","touchTimer","clearTimeout","clickTimer","waitForTouchHold","TOUCH_DELAY","setTimeout","HOLDING","WAITING_FOR_CLICK","checkBoundsAfterContextMenu","beginHover","endHover"],"sources":["C:\\Users\\macie\\IdeaProjects\\ztbd\\node_modules\\@material\\web\\ripple\\directive.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {noChange} from 'lit';\nimport {Directive, directive, DirectiveParameters, ElementPart, PartInfo, PartType} from 'lit/directive.js';\n\nimport {Ripple} from './lib/ripple.js';\n\n/**\n * Delay reacting to touch so that we do not show the ripple for a swipe or\n * scroll interaction.\n */\nconst TOUCH_DELAY_MS = 150;\n\n/**\n * Interaction states for the ripple.\n *\n * On Touch:\n *  - `INACTIVE -> TOUCH_DELAY -> WAITING_FOR_CLICK -> INACTIVE`\n *  - `INACTIVE -> TOUCH_DELAY -> HOLDING -> WAITING_FOR_CLICK -> INACTIVE`\n *\n * On Mouse or Pen:\n *   - `INACTIVE -> WAITING_FOR_CLICK -> INACTIVE`\n */\nenum State {\n  /**\n   * Initial state of the control, no touch in progress.\n   *\n   * Transitions:\n   *   - on touch down: transition to `TOUCH_DELAY`.\n   *   - on mouse down: transition to `WAITING_FOR_CLICK`.\n   */\n  INACTIVE,\n  /**\n   * Touch down has been received, waiting to determine if it's a swipe or\n   * scroll.\n   *\n   * Transitions:\n   *   - on touch up: beginPress(); transition to `WAITING_FOR_CLICK`.\n   *   - on cancel: transition to `INACTIVE`.\n   *   - after `TOUCH_DELAY_MS`: beginPress(); transition to `HOLDING`.\n   */\n  TOUCH_DELAY,\n  /**\n   * A touch has been deemed to be a press\n   *\n   * Transitions:\n   *  - on up: transition to `WAITING_FOR_CLICK`.\n   */\n  HOLDING,\n  /**\n   * The user touch has finished, transition into rest state.\n   *\n   * Transitions:\n   *   - on click endPress(); transition to `INACTIVE`.\n   */\n  WAITING_FOR_CLICK\n}\n\n/**\n * Normalized ripple accessor type.\n *\n * Use with `await rippleFunction()`\n */\ntype RippleFunction = () => Ripple|null|Promise<Ripple|null>;\n\nclass RippleDirective extends Directive {\n  private rippleGetter: RippleFunction = async () => null;\n  private element?: HTMLElement;\n  private state: State = State.INACTIVE;\n  private checkBoundsAfterContextMenu = false;\n  private rippleStartEvent: PointerEvent|null = null;\n  private touchTimer: number|null = null;\n  private clickTimer: number|null = null;\n\n  constructor(partInfo: PartInfo) {\n    super(partInfo);\n    if (partInfo.type !== PartType.ELEMENT) {\n      throw new Error('The `ripple` directive must be used on an element');\n    }\n  }\n\n  render(ripple: RippleFunction|Promise<Ripple|null>) {\n    return noChange;\n  }\n\n  // Use EventListenerObject::handleEvent interface to handle events without\n  // generating bound event handlers\n  async handleEvent(event: Event) {\n    const ripple = await this.rippleGetter();\n    if (!ripple) {\n      return;\n    }\n    switch (event.type) {\n      case 'click':\n        this.click(ripple);\n        break;\n      case 'contextmenu':\n        this.contextMenu(ripple);\n        break;\n      case 'pointercancel':\n        this.pointerCancel(ripple, event as PointerEvent);\n        break;\n      case 'pointerdown':\n        this.pointerDown(ripple, event as PointerEvent);\n        break;\n      case 'pointerenter':\n        this.pointerEnter(ripple, event as PointerEvent);\n        break;\n      case 'pointerleave':\n        this.pointerLeave(ripple, event as PointerEvent);\n        break;\n      case 'pointerup':\n        this.pointerUp(ripple, event as PointerEvent);\n        break;\n      default:\n        break;\n    }\n  }\n\n  override update(part: ElementPart, [ripple]: DirectiveParameters<this>) {\n    if (!this.element) {\n      // NOTE: addEventListener typing needs to be used with HTMLElements or a\n      // subclass\n      this.element = part.element as HTMLElement;\n      this.element.addEventListener('click', this);\n      this.element.addEventListener('contextmenu', this);\n      this.element.addEventListener('pointercancel', this);\n      this.element.addEventListener('pointerdown', this);\n      this.element.addEventListener('pointerenter', this);\n      this.element.addEventListener('pointerleave', this);\n      this.element.addEventListener('pointerup', this);\n    }\n    // Normalize given ripple accessor\n    this.rippleGetter = typeof ripple === 'function' ? ripple : () => ripple;\n    return noChange;\n  }\n\n  /**\n   * Returns `true` if\n   *  - the ripple element is enabled\n   *  - the pointer is primary for the input type\n   *  - the pointer is the pointer that started the interaction, or will start\n   * the interaction\n   *  - the pointer is a touch, or the pointer state has the primary button\n   * held, or the pointer is hovering\n   */\n  private shouldReactToEvent(\n      ripple: Ripple, ev: PointerEvent, hovering = false) {\n    const enabled = !ripple.disabled;\n    const isPrimaryPointer = ev.isPrimary;\n    const isInteractionPointer = this.rippleStartEvent === null ||\n        this.rippleStartEvent.pointerId === ev.pointerId;\n    const isPrimaryButton = ev.buttons === 1;\n    return enabled && isPrimaryPointer && isInteractionPointer &&\n        (this.isTouch(ev) || isPrimaryButton || hovering);\n  }\n\n  private isTouch({pointerType}: PointerEvent) {\n    return pointerType === 'touch';\n  }\n\n  /**\n   * Check if the event is within the bounds of the element.\n   *\n   * This is only needed for the \"stuck\" contextmenu longpress on Chrome.\n   */\n  private inBounds({x, y}: PointerEvent) {\n    const {top, left, bottom, right} = this.element!.getBoundingClientRect();\n    return x >= left && x <= right && y >= top && y <= bottom;\n  }\n\n  private beginPress(ripple: Ripple) {\n    ripple.beginPress(this.rippleStartEvent);\n  }\n\n  private endPress(ripple: Ripple) {\n    ripple.endPress();\n    this.state = State.INACTIVE;\n    this.rippleStartEvent = null;\n    if (this.touchTimer) {\n      clearTimeout(this.touchTimer);\n      this.touchTimer = null;\n    }\n    if (this.clickTimer) {\n      clearTimeout(this.clickTimer);\n      this.clickTimer = null;\n    }\n  }\n\n  private waitForTouchHold() {\n    if (this.touchTimer !== null) {\n      clearTimeout(this.touchTimer);\n    }\n    this.state = State.TOUCH_DELAY;\n    this.touchTimer = setTimeout(async () => {\n      const ripple = await this.rippleGetter();\n      if (ripple === null || this.state !== State.TOUCH_DELAY) {\n        return;\n      }\n      this.state = State.HOLDING;\n      this.beginPress(ripple);\n    }, TOUCH_DELAY_MS);\n  }\n\n  private click(ripple: Ripple) {\n    // Click is a MouseEvent in Firefox and Safari, so we cannot use\n    // `shouldReactToEvent`\n    if (ripple.disabled) {\n      return;\n    }\n    if (this.state === State.WAITING_FOR_CLICK) {\n      this.endPress(ripple);\n    } else if (this.state === State.INACTIVE) {\n      // keyboard synthesized click event\n      this.beginPress(ripple);\n      this.endPress(ripple);\n    }\n  }\n\n  private contextMenu(ripple: Ripple) {\n    if (!ripple.disabled) {\n      this.checkBoundsAfterContextMenu = true;\n      this.endPress(ripple);\n    }\n  }\n\n  private pointerDown(ripple: Ripple, ev: PointerEvent) {\n    if (!this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    this.rippleStartEvent = ev;\n    if (this.isTouch(ev)) {\n      // after a longpress contextmenu event, an extra `pointerdown` can be\n      // dispatched to the pressed element. Check that the down is within\n      // bounds of the element in this case.\n      if (this.checkBoundsAfterContextMenu && !this.inBounds(ev)) {\n        return;\n      }\n      this.checkBoundsAfterContextMenu = false;\n      this.waitForTouchHold();\n    } else {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n\n  private pointerUp(ripple: Ripple, ev: PointerEvent) {\n    if (!this.isTouch(ev) || !this.shouldReactToEvent(ripple, ev)) {\n      return;\n    }\n    if (this.state === State.HOLDING) {\n      this.state = State.WAITING_FOR_CLICK;\n    } else if (this.state === State.TOUCH_DELAY) {\n      this.state = State.WAITING_FOR_CLICK;\n      this.beginPress(ripple);\n    }\n  }\n\n  private pointerCancel(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev)) {\n      this.endPress(ripple);\n    }\n  }\n\n  private pointerEnter(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.beginHover(ev);\n    }\n  }\n\n  private pointerLeave(ripple: Ripple, ev: PointerEvent) {\n    if (this.shouldReactToEvent(ripple, ev, true)) {\n      ripple.endHover();\n      // release a held mouse or pen press that moves outside the element\n      if (!this.isTouch(ev) && this.state !== State.INACTIVE) {\n        this.endPress(ripple);\n      }\n    }\n  }\n}\n\n/**\n * Connects a Ripple element to a node that drives the interaction\n *\n * @param rippleGetter A function that returns an `md-ripple` element\n * @param simulateKeyboardClick For elements that do not issue a click on\n *     keyboard interaction, pass `true` to enable press animations on Enter or\n *     Spacebar\n */\nexport const ripple = directive(RippleDirective);"]},"metadata":{},"sourceType":"module","externalDependencies":[]}