{"ast":null,"code":"/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * A `ReactiveController` that provides root node-scoped single selection for\n * elements, similar to native `<input type=\"radio\">` selection.\n *\n * To use, elements should add the controller and call\n * `selectionController.handleCheckedChange()` in a getter/setter. This must\n * be synchronous to match native behavior.\n *\n * @example\n * const CHECKED = Symbol('checked');\n *\n * class MyToggle extends LitElement {\n *   get checked() { return this[CHECKED]; }\n *   set checked(checked: boolean) {\n *     const oldValue = this.checked;\n *     if (oldValue === checked) {\n *       return;\n *     }\n *\n *     this[CHECKED] = checked;\n *     this.selectionController.handleCheckedChange();\n *     this.requestUpdate('checked', oldValue);\n *   }\n *\n *   [CHECKED] = false;\n *\n *   private selectionController = new SingleSelectionController(this);\n *\n *   constructor() {\n *     super();\n *     this.addController(this.selectionController);\n *   }\n * }\n */\nexport class SingleSelectionController {\n  constructor(host) {\n    this.host = host;\n    this.focused = false;\n    this.root = null;\n    this.handleFocusIn = () => {\n      this.focused = true;\n      this.updateTabIndices();\n    };\n    this.handleFocusOut = () => {\n      this.focused = false;\n      this.updateTabIndices();\n    };\n    /**\n     * Handles arrow key events from the host. Using the arrow keys will\n     * select and check the next or previous sibling with the host's\n     * `name` attribute.\n     */\n    this.handleKeyDown = event => {\n      const isDown = event.key === 'ArrowDown';\n      const isUp = event.key === 'ArrowUp';\n      const isLeft = event.key === 'ArrowLeft';\n      const isRight = event.key === 'ArrowRight';\n      // Ignore non-arrow keys\n      if (!isLeft && !isRight && !isDown && !isUp) {\n        return;\n      }\n      // Don't try to select another sibling if there aren't any.\n      const siblings = this.getNamedSiblings();\n      if (!siblings.length) {\n        return;\n      }\n      // Prevent default interactions on the element for arrow keys,\n      // since this controller will introduce new behavior.\n      event.preventDefault();\n      // Check if moving forwards or backwards\n      const isRtl = getComputedStyle(this.host).direction === 'rtl';\n      const forwards = isRtl ? isLeft || isDown : isRight || isDown;\n      const hostIndex = siblings.indexOf(this.host);\n      let nextIndex = forwards ? hostIndex + 1 : hostIndex - 1;\n      // Search for the next sibling that is not disabled to select.\n      // If we return to the host index, there is nothing to select.\n      while (nextIndex !== hostIndex) {\n        if (nextIndex >= siblings.length) {\n          // Return to start if moving past the last item.\n          nextIndex = 0;\n        } else if (nextIndex < 0) {\n          // Go to end if moving before the first item.\n          nextIndex = siblings.length - 1;\n        }\n        // Check if the next sibling is disabled. If so,\n        // move the index and continue searching.\n        const nextSibling = siblings[nextIndex];\n        if (nextSibling.hasAttribute('disabled')) {\n          if (forwards) {\n            nextIndex++;\n          } else {\n            nextIndex--;\n          }\n          continue;\n        }\n        // Uncheck and remove focusability from other siblings.\n        for (const sibling of siblings) {\n          if (sibling !== nextSibling) {\n            sibling.checked = false;\n            sibling.tabIndex = -1;\n          }\n        }\n        // The next sibling should be checked and focused.\n        nextSibling.checked = true;\n        nextSibling.removeAttribute('tabindex');\n        nextSibling.focus();\n        break;\n      }\n    };\n  }\n  hostConnected() {\n    this.root = this.host.getRootNode();\n    this.host.addEventListener('keydown', this.handleKeyDown);\n    this.host.addEventListener('focusin', this.handleFocusIn);\n    this.host.addEventListener('focusout', this.handleFocusOut);\n    if (this.host.checked) {\n      // Uncheck other siblings when attached if already checked. This mimics\n      // native <input type=\"radio\"> behavior.\n      this.uncheckSiblings();\n    }\n    // Update for the newly added host.\n    this.updateTabIndices();\n  }\n  hostDisconnected() {\n    this.host.removeEventListener('keydown', this.handleKeyDown);\n    this.host.removeEventListener('focusin', this.handleFocusIn);\n    this.host.removeEventListener('focusout', this.handleFocusOut);\n    // Update for siblings that are still connected.\n    this.updateTabIndices();\n    this.root = null;\n  }\n  /**\n   * Should be called whenever the host's `checked` property changes\n   * synchronously.\n   */\n  handleCheckedChange() {\n    if (!this.host.checked) {\n      return;\n    }\n    this.uncheckSiblings();\n    this.updateTabIndices();\n  }\n  uncheckSiblings() {\n    for (const sibling of this.getNamedSiblings()) {\n      if (sibling !== this.host) {\n        sibling.checked = false;\n      }\n    }\n  }\n  /**\n   * Updates the `tabindex` of the host and its siblings.\n   */\n  updateTabIndices() {\n    // There are three tabindex states for a group of elements:\n    // 1. If any are checked, that element is focusable.\n    const siblings = this.getNamedSiblings();\n    const checkedSibling = siblings.find(sibling => sibling.checked);\n    // 2. If an element is focused, the others are no longer focusable.\n    if (checkedSibling || this.focused) {\n      const focusable = checkedSibling || this.host;\n      focusable.removeAttribute('tabindex');\n      for (const sibling of siblings) {\n        if (sibling !== focusable) {\n          sibling.tabIndex = -1;\n        }\n      }\n      return;\n    }\n    // 3. If none are checked or focused, all are focusable.\n    for (const sibling of siblings) {\n      sibling.removeAttribute('tabindex');\n    }\n  }\n  /**\n   * Retrieves all siblings in the host element's root with the same `name`\n   * attribute.\n   */\n  getNamedSiblings() {\n    const name = this.host.getAttribute('name');\n    if (!name || !this.root) {\n      return [];\n    }\n    return Array.from(this.root.querySelectorAll(`[name=\"${name}\"]`));\n  }\n}","map":{"version":3,"mappings":"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","names":["SingleSelectionController","constructor","host","focused","updateTabIndices","event","isDown","key","isUp","isLeft","isRight","siblings","getNamedSiblings","length","preventDefault","isRtl","getComputedStyle","direction","forwards","hostIndex","indexOf","nextIndex","nextSibling","hasAttribute","sibling","checked","tabIndex","removeAttribute","focus","hostConnected","root","getRootNode","addEventListener","handleKeyDown","handleFocusIn","handleFocusOut","uncheckSiblings","hostDisconnected","removeEventListener","handleCheckedChange","checkedSibling","find","focusable","name","getAttribute","Array","from","querySelectorAll"],"sources":["C:\\Users\\macie\\IdeaProjects\\ztbd\\node_modules\\@material\\web\\radio\\lib\\single-selection-controller.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2022 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveController} from 'lit';\n\n/**\n * An element that supports single-selection with `SingleSelectionController`.\n */\nexport interface SingleSelectionElement extends HTMLElement {\n  /**\n   * Whether or not the element is selected.\n   */\n  checked: boolean;\n}\n\n/**\n * A `ReactiveController` that provides root node-scoped single selection for\n * elements, similar to native `<input type=\"radio\">` selection.\n *\n * To use, elements should add the controller and call\n * `selectionController.handleCheckedChange()` in a getter/setter. This must\n * be synchronous to match native behavior.\n *\n * @example\n * const CHECKED = Symbol('checked');\n *\n * class MyToggle extends LitElement {\n *   get checked() { return this[CHECKED]; }\n *   set checked(checked: boolean) {\n *     const oldValue = this.checked;\n *     if (oldValue === checked) {\n *       return;\n *     }\n *\n *     this[CHECKED] = checked;\n *     this.selectionController.handleCheckedChange();\n *     this.requestUpdate('checked', oldValue);\n *   }\n *\n *   [CHECKED] = false;\n *\n *   private selectionController = new SingleSelectionController(this);\n *\n *   constructor() {\n *     super();\n *     this.addController(this.selectionController);\n *   }\n * }\n */\nexport class SingleSelectionController implements ReactiveController {\n  private focused = false;\n  private root: ParentNode|null = null;\n\n  constructor(private readonly host: SingleSelectionElement) {}\n\n  hostConnected() {\n    this.root = this.host.getRootNode() as ParentNode;\n    this.host.addEventListener('keydown', this.handleKeyDown);\n    this.host.addEventListener('focusin', this.handleFocusIn);\n    this.host.addEventListener('focusout', this.handleFocusOut);\n    if (this.host.checked) {\n      // Uncheck other siblings when attached if already checked. This mimics\n      // native <input type=\"radio\"> behavior.\n      this.uncheckSiblings();\n    }\n\n    // Update for the newly added host.\n    this.updateTabIndices();\n  }\n\n  hostDisconnected() {\n    this.host.removeEventListener('keydown', this.handleKeyDown);\n    this.host.removeEventListener('focusin', this.handleFocusIn);\n    this.host.removeEventListener('focusout', this.handleFocusOut);\n    // Update for siblings that are still connected.\n    this.updateTabIndices();\n    this.root = null;\n  }\n\n  /**\n   * Should be called whenever the host's `checked` property changes\n   * synchronously.\n   */\n  handleCheckedChange() {\n    if (!this.host.checked) {\n      return;\n    }\n\n    this.uncheckSiblings();\n    this.updateTabIndices();\n  }\n\n  private readonly handleFocusIn = () => {\n    this.focused = true;\n    this.updateTabIndices();\n  };\n\n  private readonly handleFocusOut = () => {\n    this.focused = false;\n    this.updateTabIndices();\n  };\n\n  private uncheckSiblings() {\n    for (const sibling of this.getNamedSiblings()) {\n      if (sibling !== this.host) {\n        sibling.checked = false;\n      }\n    }\n  }\n\n  /**\n   * Updates the `tabindex` of the host and its siblings.\n   */\n  private updateTabIndices() {\n    // There are three tabindex states for a group of elements:\n    // 1. If any are checked, that element is focusable.\n    const siblings = this.getNamedSiblings();\n    const checkedSibling = siblings.find(sibling => sibling.checked);\n    // 2. If an element is focused, the others are no longer focusable.\n    if (checkedSibling || this.focused) {\n      const focusable = checkedSibling || this.host;\n      focusable.removeAttribute('tabindex');\n\n      for (const sibling of siblings) {\n        if (sibling !== focusable) {\n          sibling.tabIndex = -1;\n        }\n      }\n      return;\n    }\n\n    // 3. If none are checked or focused, all are focusable.\n    for (const sibling of siblings) {\n      sibling.removeAttribute('tabindex');\n    }\n  }\n\n  /**\n   * Retrieves all siblings in the host element's root with the same `name`\n   * attribute.\n   */\n  private getNamedSiblings() {\n    const name = this.host.getAttribute('name');\n    if (!name || !this.root) {\n      return [];\n    }\n\n    return Array.from(\n        this.root.querySelectorAll<SingleSelectionElement>(`[name=\"${name}\"]`));\n  }\n\n  /**\n   * Handles arrow key events from the host. Using the arrow keys will\n   * select and check the next or previous sibling with the host's\n   * `name` attribute.\n   */\n  private readonly handleKeyDown = (event: KeyboardEvent) => {\n    const isDown = event.key === 'ArrowDown';\n    const isUp = event.key === 'ArrowUp';\n    const isLeft = event.key === 'ArrowLeft';\n    const isRight = event.key === 'ArrowRight';\n    // Ignore non-arrow keys\n    if (!isLeft && !isRight && !isDown && !isUp) {\n      return;\n    }\n\n    // Don't try to select another sibling if there aren't any.\n    const siblings = this.getNamedSiblings();\n    if (!siblings.length) {\n      return;\n    }\n\n    // Prevent default interactions on the element for arrow keys,\n    // since this controller will introduce new behavior.\n    event.preventDefault();\n\n    // Check if moving forwards or backwards\n    const isRtl = getComputedStyle(this.host).direction === 'rtl';\n    const forwards = isRtl ? isLeft || isDown : isRight || isDown;\n\n    const hostIndex = siblings.indexOf(this.host);\n    let nextIndex = forwards ? hostIndex + 1 : hostIndex - 1;\n    // Search for the next sibling that is not disabled to select.\n    // If we return to the host index, there is nothing to select.\n    while (nextIndex !== hostIndex) {\n      if (nextIndex >= siblings.length) {\n        // Return to start if moving past the last item.\n        nextIndex = 0;\n      } else if (nextIndex < 0) {\n        // Go to end if moving before the first item.\n        nextIndex = siblings.length - 1;\n      }\n\n      // Check if the next sibling is disabled. If so,\n      // move the index and continue searching.\n      const nextSibling = siblings[nextIndex];\n      if (nextSibling.hasAttribute('disabled')) {\n        if (forwards) {\n          nextIndex++;\n        } else {\n          nextIndex--;\n        }\n\n        continue;\n      }\n\n      // Uncheck and remove focusability from other siblings.\n      for (const sibling of siblings) {\n        if (sibling !== nextSibling) {\n          sibling.checked = false;\n          sibling.tabIndex = -1;\n        }\n      }\n\n      // The next sibling should be checked and focused.\n      nextSibling.checked = true;\n      nextSibling.removeAttribute('tabindex');\n      nextSibling.focus();\n      break;\n    }\n  };\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}