{"ast":null,"code":"import { __assign, __rest } from \"tslib\";\nimport { createOperatorSubscriber } from '../../operators/OperatorSubscriber';\nimport { Observable } from '../../Observable';\nimport { innerFrom } from '../../observable/innerFrom';\nexport function fromFetch(input, initWithSelector) {\n  if (initWithSelector === void 0) {\n    initWithSelector = {};\n  }\n  var selector = initWithSelector.selector,\n    init = __rest(initWithSelector, [\"selector\"]);\n  return new Observable(function (subscriber) {\n    var controller = new AbortController();\n    var signal = controller.signal;\n    var abortable = true;\n    var outerSignal = init.signal;\n    if (outerSignal) {\n      if (outerSignal.aborted) {\n        controller.abort();\n      } else {\n        var outerSignalHandler_1 = function () {\n          if (!signal.aborted) {\n            controller.abort();\n          }\n        };\n        outerSignal.addEventListener('abort', outerSignalHandler_1);\n        subscriber.add(function () {\n          return outerSignal.removeEventListener('abort', outerSignalHandler_1);\n        });\n      }\n    }\n    var perSubscriberInit = __assign(__assign({}, init), {\n      signal: signal\n    });\n    var handleError = function (err) {\n      abortable = false;\n      subscriber.error(err);\n    };\n    fetch(input, perSubscriberInit).then(function (response) {\n      if (selector) {\n        innerFrom(selector(response)).subscribe(createOperatorSubscriber(subscriber, undefined, function () {\n          abortable = false;\n          subscriber.complete();\n        }, handleError));\n      } else {\n        abortable = false;\n        subscriber.next(response);\n        subscriber.complete();\n      }\n    }).catch(handleError);\n    return function () {\n      if (abortable) {\n        controller.abort();\n      }\n    };\n  });\n}","map":{"version":3,"mappings":";AAAA,SAASA,wBAAwB,QAAQ,oCAAoC;AAC7E,SAASC,UAAU,QAAQ,kBAAkB;AAC7C,SAASC,SAAS,QAAQ,4BAA4B;AA4FtD,OAAM,SAAUC,SAAS,CACvBC,KAAuB,EACvBC,gBAEM;EAFN;IAAAA,qBAEM;EAAA;EAEE,YAAQ,GAAcA,gBAAgB,SAA9B;IAAKC,IAAI,UAAKD,gBAAgB,EAAxC,YAAqB,CAAF;EACzB,OAAO,IAAIJ,UAAU,CAAe,UAACM,UAAU;IAK7C,IAAMC,UAAU,GAAG,IAAIC,eAAe,EAAE;IAChC,UAAM,GAAKD,UAAU,OAAf;IAKd,IAAIE,SAAS,GAAG,IAAI;IAKZ,IAAQC,WAAW,GAAKL,IAAI,OAAT;IAC3B,IAAIK,WAAW,EAAE;MACf,IAAIA,WAAW,CAACC,OAAO,EAAE;QACvBJ,UAAU,CAACK,KAAK,EAAE;OACnB,MAAM;QAGL,IAAMC,oBAAkB,GAAG;UACzB,IAAI,CAACC,MAAM,CAACH,OAAO,EAAE;YACnBJ,UAAU,CAACK,KAAK,EAAE;;QAEtB,CAAC;QACDF,WAAW,CAACK,gBAAgB,CAAC,OAAO,EAAEF,oBAAkB,CAAC;QACzDP,UAAU,CAACU,GAAG,CAAC;UAAM,kBAAW,CAACC,mBAAmB,CAAC,OAAO,EAAEJ,oBAAkB,CAAC;QAA5D,CAA4D,CAAC;;;IAStF,IAAMK,iBAAiB,yBAAqBb,IAAI;MAAES,MAAM;IAAA,EAAE;IAE1D,IAAMK,WAAW,GAAG,UAACC,GAAQ;MAC3BX,SAAS,GAAG,KAAK;MACjBH,UAAU,CAACe,KAAK,CAACD,GAAG,CAAC;IACvB,CAAC;IAEDE,KAAK,CAACnB,KAAK,EAAEe,iBAAiB,CAAC,CAC5BK,IAAI,CAAC,UAACC,QAAQ;MACb,IAAIC,QAAQ,EAAE;QAIZxB,SAAS,CAACwB,QAAQ,CAACD,QAAQ,CAAC,CAAC,CAACE,SAAS,CACrC3B,wBAAwB,CACtBO,UAAU,EAEVqB,SAAS,EAET;UACElB,SAAS,GAAG,KAAK;UACjBH,UAAU,CAACsB,QAAQ,EAAE;QACvB,CAAC,EACDT,WAAW,CACZ,CACF;OACF,MAAM;QACLV,SAAS,GAAG,KAAK;QACjBH,UAAU,CAACuB,IAAI,CAACL,QAAQ,CAAC;QACzBlB,UAAU,CAACsB,QAAQ,EAAE;;IAEzB,CAAC,CAAC,CACDE,KAAK,CAACX,WAAW,CAAC;IAErB,OAAO;MACL,IAAIV,SAAS,EAAE;QACbF,UAAU,CAACK,KAAK,EAAE;;IAEtB,CAAC;EACH,CAAC,CAAC;AACJ","names":["createOperatorSubscriber","Observable","innerFrom","fromFetch","input","initWithSelector","init","subscriber","controller","AbortController","abortable","outerSignal","aborted","abort","outerSignalHandler_1","signal","addEventListener","add","removeEventListener","perSubscriberInit","handleError","err","error","fetch","then","response","selector","subscribe","undefined","complete","next","catch"],"sources":["C:\\Users\\macie\\IdeaProjects\\ztbd\\node_modules\\rxjs\\src\\internal\\observable\\dom\\fetch.ts"],"sourcesContent":["import { createOperatorSubscriber } from '../../operators/OperatorSubscriber';\nimport { Observable } from '../../Observable';\nimport { innerFrom } from '../../observable/innerFrom';\nimport { ObservableInput } from '../../types';\n\nexport function fromFetch<T>(\n  input: string | Request,\n  init: RequestInit & {\n    selector: (response: Response) => ObservableInput<T>;\n  }\n): Observable<T>;\n\nexport function fromFetch(input: string | Request, init?: RequestInit): Observable<Response>;\n\n/**\n * Uses [the Fetch API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) to\n * make an HTTP request.\n *\n * **WARNING** Parts of the fetch API are still experimental. `AbortController` is\n * required for this implementation to work and use cancellation appropriately.\n *\n * Will automatically set up an internal [AbortController](https://developer.mozilla.org/en-US/docs/Web/API/AbortController)\n * in order to finalize the internal `fetch` when the subscription tears down.\n *\n * If a `signal` is provided via the `init` argument, it will behave like it usually does with\n * `fetch`. If the provided `signal` aborts, the error that `fetch` normally rejects with\n * in that scenario will be emitted as an error from the observable.\n *\n * ## Examples\n *\n * Basic use\n *\n * ```ts\n * import { fromFetch } from 'rxjs/fetch';\n * import { switchMap, of, catchError } from 'rxjs';\n *\n * const data$ = fromFetch('https://api.github.com/users?per_page=5').pipe(\n *   switchMap(response => {\n *     if (response.ok) {\n *       // OK return data\n *       return response.json();\n *     } else {\n *       // Server is returning a status requiring the client to try something else.\n *       return of({ error: true, message: `Error ${ response.status }` });\n *     }\n *   }),\n *   catchError(err => {\n *     // Network or other error, handle appropriately\n *     console.error(err);\n *     return of({ error: true, message: err.message })\n *   })\n * );\n *\n * data$.subscribe({\n *   next: result => console.log(result),\n *   complete: () => console.log('done')\n * });\n * ```\n *\n * ### Use with Chunked Transfer Encoding\n *\n * With HTTP responses that use [chunked transfer encoding](https://tools.ietf.org/html/rfc7230#section-3.3.1),\n * the promise returned by `fetch` will resolve as soon as the response's headers are\n * received.\n *\n * That means the `fromFetch` observable will emit a `Response` - and will\n * then complete - before the body is received. When one of the methods on the\n * `Response` - like `text()` or `json()` - is called, the returned promise will not\n * resolve until the entire body has been received. Unsubscribing from any observable\n * that uses the promise as an observable input will not abort the request.\n *\n * To facilitate aborting the retrieval of responses that use chunked transfer encoding,\n * a `selector` can be specified via the `init` parameter:\n *\n * ```ts\n * import { of } from 'rxjs';\n * import { fromFetch } from 'rxjs/fetch';\n *\n * const data$ = fromFetch('https://api.github.com/users?per_page=5', {\n *   selector: response => response.json()\n * });\n *\n * data$.subscribe({\n *   next: result => console.log(result),\n *   complete: () => console.log('done')\n * });\n * ```\n *\n * @param input The resource you would like to fetch. Can be a url or a request object.\n * @param initWithSelector A configuration object for the fetch.\n * [See MDN for more details](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch#Parameters)\n * @returns An Observable, that when subscribed to, performs an HTTP request using the native `fetch`\n * function. The {@link Subscription} is tied to an `AbortController` for the fetch.\n */\nexport function fromFetch<T>(\n  input: string | Request,\n  initWithSelector: RequestInit & {\n    selector?: (response: Response) => ObservableInput<T>;\n  } = {}\n): Observable<Response | T> {\n  const { selector, ...init } = initWithSelector;\n  return new Observable<Response | T>((subscriber) => {\n    // Our controller for aborting this fetch.\n    // Any externally provided AbortSignal will have to call\n    // abort on this controller when signaled, because the\n    // signal from this controller is what is being passed to `fetch`.\n    const controller = new AbortController();\n    const { signal } = controller;\n    // This flag exists to make sure we don't `abort()` the fetch upon tearing down\n    // this observable after emitting a Response. Aborting in such circumstances\n    // would also abort subsequent methods - like `json()` - that could be called\n    // on the Response. Consider: `fromFetch().pipe(take(1), mergeMap(res => res.json()))`\n    let abortable = true;\n\n    // If the user provided an init configuration object,\n    // let's process it and chain our abort signals, if necessary.\n    // If a signal is provided, just have it finalized. It's a cancellation token, basically.\n    const { signal: outerSignal } = init;\n    if (outerSignal) {\n      if (outerSignal.aborted) {\n        controller.abort();\n      } else {\n        // We got an AbortSignal from the arguments passed into `fromFetch`.\n        // We need to wire up our AbortController to abort when this signal aborts.\n        const outerSignalHandler = () => {\n          if (!signal.aborted) {\n            controller.abort();\n          }\n        };\n        outerSignal.addEventListener('abort', outerSignalHandler);\n        subscriber.add(() => outerSignal.removeEventListener('abort', outerSignalHandler));\n      }\n    }\n\n    // The initialization object passed to `fetch` as the second\n    // argument. This ferries in important information, including our\n    // AbortSignal. Create a new init, so we don't accidentally mutate the\n    // passed init, or reassign it. This is because the init passed in\n    // is shared between each subscription to the result.\n    const perSubscriberInit: RequestInit = { ...init, signal };\n\n    const handleError = (err: any) => {\n      abortable = false;\n      subscriber.error(err);\n    };\n\n    fetch(input, perSubscriberInit)\n      .then((response) => {\n        if (selector) {\n          // If we have a selector function, use it to project our response.\n          // Note that any error that comes from our selector will be\n          // sent to the promise `catch` below and handled.\n          innerFrom(selector(response)).subscribe(\n            createOperatorSubscriber(\n              subscriber,\n              // Values are passed through to the subscriber\n              undefined,\n              // The projected response is complete.\n              () => {\n                abortable = false;\n                subscriber.complete();\n              },\n              handleError\n            )\n          );\n        } else {\n          abortable = false;\n          subscriber.next(response);\n          subscriber.complete();\n        }\n      })\n      .catch(handleError);\n\n    return () => {\n      if (abortable) {\n        controller.abort();\n      }\n    };\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}