{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * A property decorator that helps proxy an aria attribute to an internal node.\n *\n * This decorator is only intended for use with ARIAMixin properties,\n * such as `ariaLabel`, to help with screen readers.\n *\n * This decorator will remove the host `aria-*` attribute at runtime and add it\n * to a `data-aria-*` attribute to avoid screenreader conflicts between the\n * host and internal node.\n *\n * `@ariaProperty` decorated properties should sync with LitElement to the\n * `data-aria-*` attribute, not the native `aria-*` attribute.\n *\n * @example\n * ```ts\n * class MyElement extends LitElement {\n *   \\@ariaProperty\n *   // TODO(b/210730484): replace with @soyParam annotation\n *   \\@property({ type: String, attribute: 'data-aria-label', noAccessor: true})\n *   ariaLabel!: string;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function ariaProperty(prototype, property) {\n  // Replace the ARIAMixin property with data-* attribute syncing instead of\n  // using the native aria-* attribute reflection. This preserves the attribute\n  // for SSR and avoids screenreader conflicts after delegating the attribute\n  // to a child node.\n  Object.defineProperty(prototype, property, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      return this.dataset[property] ?? '';\n    },\n    set(value) {\n      // Coerce non-string values to a string\n      const strValue = String(value ?? '');\n      if (strValue) {\n        this.dataset[property] = strValue;\n      } else {\n        delete this.dataset[property];\n      }\n      // lit will call this setter whenever the data-* attribute changes.\n      // However, this.dataset[property] will automatically be updated to the\n      // current value. To avoid bugs, always request an update regardless of\n      // the old value.\n      this.requestUpdate();\n    }\n  });\n  // Define an internal property that syncs from the `aria-*` attribute with lit\n  // and delegates to the real ARIAMixin property, which renders an update.\n  // This property will immediately remove the `aria-*` attribute, which doesn't\n  // work well with SSR (which is why there's a separate synced property).\n  const internalAriaProperty = Symbol(property);\n  // \"ariaLabel\" -> \"aria-label\" / \"ariaLabelledBy\" -> \"aria-labelledby\"\n  const ariaAttribute = property.replace('aria', 'aria-').toLowerCase();\n  const constructor = prototype.constructor;\n  let removingAttribute = false;\n  Object.defineProperty(prototype, internalAriaProperty, {\n    get() {\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      return this[property];\n    },\n    set(value) {\n      if (removingAttribute) {\n        // Ignore this update, which is triggered below\n        return;\n      }\n      // Set the ARIAMixin property, which will sync the `data-*` attribute\n      // and trigger rendering if the value changed.\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      this[property] = value;\n      // Remove the `aria-*` attribute, which will call this setter again with\n      // the incorrect value. Ignore these updates.\n      removingAttribute = true;\n      this.removeAttribute(ariaAttribute);\n      removingAttribute = false;\n    }\n  });\n  // Tell lit to observe the `aria-*` attribute and set the internal property,\n  // which acts as a \"aria-* attribute changed\" observer.\n  constructor.createProperty(internalAriaProperty, {\n    attribute: ariaAttribute,\n    noAccessor: true\n  });\n}","map":{"version":3,"mappings":"AAAA;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAUA,YAAY,CAExBC,SAAY,EAAEC,QAAW;EAC3B;EACA;EACA;EACA;EACAC,MAAM,CAACC,cAAc,CAACH,SAAS,EAAEC,QAAQ,EAAE;IACzCG,YAAY,EAAE,IAAI;IAClBC,UAAU,EAAE,IAAI;IAChBC,GAAG;MACD,OAAO,IAAI,CAACC,OAAO,CAACN,QAAQ,CAAC,IAAI,EAAE;IACrC,CAAC;IACDO,GAAG,CAAwBC,KAAc;MACvC;MACA,MAAMC,QAAQ,GAAGC,MAAM,CAACF,KAAK,IAAI,EAAE,CAAC;MACpC,IAAIC,QAAQ,EAAE;QACZ,IAAI,CAACH,OAAO,CAACN,QAAQ,CAAC,GAAGS,QAAQ;OAClC,MAAM;QACL,OAAO,IAAI,CAACH,OAAO,CAACN,QAAQ,CAAC;;MAG/B;MACA;MACA;MACA;MACA,IAAI,CAACW,aAAa,EAAE;IACtB;GACD,CAAC;EAEF;EACA;EACA;EACA;EACA,MAAMC,oBAAoB,GAAGC,MAAM,CAACb,QAAQ,CAAC;EAC7C;EACA,MAAMc,aAAa,GAAGd,QAAQ,CAACe,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,CAACC,WAAW,EAAE;EACrE,MAAMC,WAAW,GAAIlB,SAAS,CAACkB,WAAsC;EACrE,IAAIC,iBAAiB,GAAG,KAAK;EAC7BjB,MAAM,CAACC,cAAc,CAACH,SAAS,EAAEa,oBAAoB,EAAE;IACrDP,GAAG;MACD;MACA;MACA;MACA,OAAQ,IAAU,CAACL,QAAQ,CAAC;IAC9B,CAAC;IACDO,GAAG,CAAwBC,KAAW;MACpC,IAAIU,iBAAiB,EAAE;QACrB;QACA;;MAGF;MACA;MACA;MACA;MACA;MACC,IAAU,CAAClB,QAAQ,CAAC,GAAGQ,KAAK;MAC7B;MACA;MACAU,iBAAiB,GAAG,IAAI;MACxB,IAAI,CAACC,eAAe,CAACL,aAAa,CAAC;MACnCI,iBAAiB,GAAG,KAAK;IAC3B;GACD,CAAC;EAEF;EACA;EACAD,WAAW,CAACG,cAAc,CAACR,oBAAoB,EAAE;IAC/CS,SAAS,EAAEP,aAAa;IACxBQ,UAAU,EAAE;GACb,CAAC;AACJ","names":["ariaProperty","prototype","property","Object","defineProperty","configurable","enumerable","get","dataset","set","value","strValue","String","requestUpdate","internalAriaProperty","Symbol","ariaAttribute","replace","toLowerCase","constructor","removingAttribute","removeAttribute","createProperty","attribute","noAccessor"],"sources":["C:\\Users\\macie\\IdeaProjects\\ztbd\\node_modules\\@material\\web\\decorators\\aria-property.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ReactiveElement} from 'lit';\n\n/**\n * A property decorator that helps proxy an aria attribute to an internal node.\n *\n * This decorator is only intended for use with ARIAMixin properties,\n * such as `ariaLabel`, to help with screen readers.\n *\n * This decorator will remove the host `aria-*` attribute at runtime and add it\n * to a `data-aria-*` attribute to avoid screenreader conflicts between the\n * host and internal node.\n *\n * `@ariaProperty` decorated properties should sync with LitElement to the\n * `data-aria-*` attribute, not the native `aria-*` attribute.\n *\n * @example\n * ```ts\n * class MyElement extends LitElement {\n *   \\@ariaProperty\n *   // TODO(b/210730484): replace with @soyParam annotation\n *   \\@property({ type: String, attribute: 'data-aria-label', noAccessor: true})\n *   ariaLabel!: string;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function ariaProperty<E extends ReactiveElement, K extends keyof E&\n                             (`aria${string}` | 'role')>(\n    prototype: E, property: K) {\n  // Replace the ARIAMixin property with data-* attribute syncing instead of\n  // using the native aria-* attribute reflection. This preserves the attribute\n  // for SSR and avoids screenreader conflicts after delegating the attribute\n  // to a child node.\n  Object.defineProperty(prototype, property, {\n    configurable: true,\n    enumerable: true,\n    get(this: ReactiveElement) {\n      return this.dataset[property] ?? '';\n    },\n    set(this: ReactiveElement, value: unknown) {\n      // Coerce non-string values to a string\n      const strValue = String(value ?? '');\n      if (strValue) {\n        this.dataset[property] = strValue;\n      } else {\n        delete this.dataset[property];\n      }\n\n      // lit will call this setter whenever the data-* attribute changes.\n      // However, this.dataset[property] will automatically be updated to the\n      // current value. To avoid bugs, always request an update regardless of\n      // the old value.\n      this.requestUpdate();\n    }\n  });\n\n  // Define an internal property that syncs from the `aria-*` attribute with lit\n  // and delegates to the real ARIAMixin property, which renders an update.\n  // This property will immediately remove the `aria-*` attribute, which doesn't\n  // work well with SSR (which is why there's a separate synced property).\n  const internalAriaProperty = Symbol(property);\n  // \"ariaLabel\" -> \"aria-label\" / \"ariaLabelledBy\" -> \"aria-labelledby\"\n  const ariaAttribute = property.replace('aria', 'aria-').toLowerCase();\n  const constructor = (prototype.constructor as typeof ReactiveElement);\n  let removingAttribute = false;\n  Object.defineProperty(prototype, internalAriaProperty, {\n    get(this: ReactiveElement) {\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      return (this as E)[property];\n    },\n    set(this: ReactiveElement, value: E[K]) {\n      if (removingAttribute) {\n        // Ignore this update, which is triggered below\n        return;\n      }\n\n      // Set the ARIAMixin property, which will sync the `data-*` attribute\n      // and trigger rendering if the value changed.\n      // tslint is failing here, but the types are correct (ARIAMixin\n      // properties do not obfuscate with closure)\n      // tslint:disable-next-line:no-dict-access-on-struct-type\n      (this as E)[property] = value;\n      // Remove the `aria-*` attribute, which will call this setter again with\n      // the incorrect value. Ignore these updates.\n      removingAttribute = true;\n      this.removeAttribute(ariaAttribute);\n      removingAttribute = false;\n    }\n  });\n\n  // Tell lit to observe the `aria-*` attribute and set the internal property,\n  // which acts as a \"aria-* attribute changed\" observer.\n  constructor.createProperty(internalAriaProperty, {\n    attribute: ariaAttribute,\n    noAccessor: true,\n  });\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}