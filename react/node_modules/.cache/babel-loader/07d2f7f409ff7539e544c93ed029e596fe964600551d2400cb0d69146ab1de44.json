{"ast":null,"code":"/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * Re-dispatches an event from the provided element.\n *\n * This function is useful for forwarding non-composed events, such as `change`\n * events.\n *\n * @example\n * class MyInput extends LitElement {\n *   render() {\n *     return html`<input @change=${this.redispatchEvent}>`;\n *   }\n *\n *   protected redispatchEvent(event: Event) {\n *     redispatchEvent(this, event);\n *   }\n * }\n *\n * @param element The element to dispatch the event from.\n * @param event The event to re-dispatch.\n * @return Whether or not the event was dispatched (if cancelable).\n */\nexport function redispatchEvent(element, event) {\n  // For bubbling events in SSR light DOM (or composed), stop their propagation\n  // and dispatch the copy.\n  if (event.bubbles && (!element.shadowRoot || event.composed)) {\n    event.stopPropagation();\n  }\n  const copy = Reflect.construct(event.constructor, [event.type, event]);\n  const dispatched = element.dispatchEvent(copy);\n  if (!dispatched) {\n    event.preventDefault();\n  }\n  return dispatched;\n}\n/**\n * Dispatches a click event to the given element that triggers a native action,\n * but is not composed and therefore is not seen outside the element.\n *\n * This is useful for responding to an external click event on the host element\n * that should trigger an internal action like a button click.\n *\n * Note, a helper is provided because setting this up correctly is a bit tricky.\n * In particular, calling `click` on an element creates a composed event, which\n * is not desirable, and a manually dispatched event must specifically be a\n * `MouseEvent` to trigger a native action.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function dispatchActivationClick(element) {\n  const event = new MouseEvent('click', {\n    bubbles: true\n  });\n  element.dispatchEvent(event);\n  return event;\n}\n/**\n * Returns true if the click event should trigger an activation behavior. The\n * behavior is defined by the element and is whatever it should do when\n * clicked.\n *\n * Typically when an element needs to handle a click, the click is generated\n * from within the element and an event listener within the element implements\n * the needed behavior; however, it's possible to fire a click directly\n * at the element that the element should handle. This method helps\n * distinguish these \"external\" clicks.\n *\n * An \"external\" click can be triggered in a number of ways: via a click\n * on an associated label for a form  associated element, calling\n * `element.click()`, or calling\n * `element.dispatchEvent(new MouseEvent('click', ...))`.\n *\n * Also works around Firefox issue\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1804576 by squelching\n * events for a microtask after called.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function isActivationClick(event) {\n  // Event must start at the event target.\n  if (event.composedPath()[0] !== event.target) {\n    return false;\n  }\n  // Target must not be disabled; this should only occur for a synthetically\n  // dispatched click.\n  if (event.target.disabled) {\n    return false;\n  }\n  // This is an activation if the event should not be squelched.\n  return !squelchEvent(event);\n}\n// TODO(https://bugzilla.mozilla.org/show_bug.cgi?id=1804576)\n//  Remove when Firefox bug is addressed.\nfunction squelchEvent(event) {\n  const squelched = isSquelchingEvents;\n  if (squelched) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n  squelchEventsForMicrotask();\n  return squelched;\n}\n// Ignore events for one microtask only.\nlet isSquelchingEvents = false;\nasync function squelchEventsForMicrotask() {\n  isSquelchingEvents = true;\n  // Need to pause for just one microtask.\n  // tslint:disable-next-line\n  await null;\n  isSquelchingEvents = false;\n}","map":{"version":3,"mappings":"AAAA;;;;;AAMA;;;;;;;;;;;;;;;;;;;;;AAqBA,OAAM,SAAUA,eAAe,CAACC,OAAgB,EAAEC,KAAY;EAC5D;EACA;EACA,IAAIA,KAAK,CAACC,OAAO,KAAK,CAACF,OAAO,CAACG,UAAU,IAAIF,KAAK,CAACG,QAAQ,CAAC,EAAE;IAC5DH,KAAK,CAACI,eAAe,EAAE;;EAGzB,MAAMC,IAAI,GAAGC,OAAO,CAACC,SAAS,CAACP,KAAK,CAACQ,WAAW,EAAE,CAACR,KAAK,CAACS,IAAI,EAAET,KAAK,CAAC,CAAC;EACtE,MAAMU,UAAU,GAAGX,OAAO,CAACY,aAAa,CAACN,IAAI,CAAC;EAC9C,IAAI,CAACK,UAAU,EAAE;IACfV,KAAK,CAACY,cAAc,EAAE;;EAGxB,OAAOF,UAAU;AACnB;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA,OAAM,SAAUG,uBAAuB,CAACd,OAAoB;EAC1D,MAAMC,KAAK,GAAG,IAAIc,UAAU,CAAC,OAAO,EAAE;IAACb,OAAO,EAAE;EAAI,CAAC,CAAC;EACtDF,OAAO,CAACY,aAAa,CAACX,KAAK,CAAC;EAC5B,OAAOA,KAAK;AACd;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA,OAAM,SAAUe,iBAAiB,CAACf,KAAY;EAC5C;EACA,IAAIA,KAAK,CAACgB,YAAY,EAAE,CAAC,CAAC,CAAC,KAAKhB,KAAK,CAACiB,MAAM,EAAE;IAC5C,OAAO,KAAK;;EAEd;EACA;EACA,IAAKjB,KAAK,CAACiB,MAA4C,CAACC,QAAQ,EAAE;IAChE,OAAO,KAAK;;EAEd;EACA,OAAO,CAACC,YAAY,CAACnB,KAAK,CAAC;AAC7B;AAEA;AACA;AACA,SAASmB,YAAY,CAACnB,KAAY;EAChC,MAAMoB,SAAS,GAAGC,kBAAkB;EACpC,IAAID,SAAS,EAAE;IACbpB,KAAK,CAACY,cAAc,EAAE;IACtBZ,KAAK,CAACsB,wBAAwB,EAAE;;EAElCC,yBAAyB,EAAE;EAC3B,OAAOH,SAAS;AAClB;AAEA;AACA,IAAIC,kBAAkB,GAAG,KAAK;AAC9B,eAAeE,yBAAyB;EACtCF,kBAAkB,GAAG,IAAI;EACzB;EACA;EACA,MAAM,IAAI;EACVA,kBAAkB,GAAG,KAAK;AAC5B","names":["redispatchEvent","element","event","bubbles","shadowRoot","composed","stopPropagation","copy","Reflect","construct","constructor","type","dispatched","dispatchEvent","preventDefault","dispatchActivationClick","MouseEvent","isActivationClick","composedPath","target","disabled","squelchEvent","squelched","isSquelchingEvents","stopImmediatePropagation","squelchEventsForMicrotask"],"sources":["C:\\Users\\macie\\IdeaProjects\\ztbd\\node_modules\\@material\\web\\controller\\events.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Re-dispatches an event from the provided element.\n *\n * This function is useful for forwarding non-composed events, such as `change`\n * events.\n *\n * @example\n * class MyInput extends LitElement {\n *   render() {\n *     return html`<input @change=${this.redispatchEvent}>`;\n *   }\n *\n *   protected redispatchEvent(event: Event) {\n *     redispatchEvent(this, event);\n *   }\n * }\n *\n * @param element The element to dispatch the event from.\n * @param event The event to re-dispatch.\n * @return Whether or not the event was dispatched (if cancelable).\n */\nexport function redispatchEvent(element: Element, event: Event) {\n  // For bubbling events in SSR light DOM (or composed), stop their propagation\n  // and dispatch the copy.\n  if (event.bubbles && (!element.shadowRoot || event.composed)) {\n    event.stopPropagation();\n  }\n\n  const copy = Reflect.construct(event.constructor, [event.type, event]);\n  const dispatched = element.dispatchEvent(copy);\n  if (!dispatched) {\n    event.preventDefault();\n  }\n\n  return dispatched;\n}\n\n/**\n * Dispatches a click event to the given element that triggers a native action,\n * but is not composed and therefore is not seen outside the element.\n *\n * This is useful for responding to an external click event on the host element\n * that should trigger an internal action like a button click.\n *\n * Note, a helper is provided because setting this up correctly is a bit tricky.\n * In particular, calling `click` on an element creates a composed event, which\n * is not desirable, and a manually dispatched event must specifically be a\n * `MouseEvent` to trigger a native action.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function dispatchActivationClick(element: HTMLElement) {\n  const event = new MouseEvent('click', {bubbles: true});\n  element.dispatchEvent(event);\n  return event;\n}\n\n/**\n * Returns true if the click event should trigger an activation behavior. The\n * behavior is defined by the element and is whatever it should do when\n * clicked.\n *\n * Typically when an element needs to handle a click, the click is generated\n * from within the element and an event listener within the element implements\n * the needed behavior; however, it's possible to fire a click directly\n * at the element that the element should handle. This method helps\n * distinguish these \"external\" clicks.\n *\n * An \"external\" click can be triggered in a number of ways: via a click\n * on an associated label for a form  associated element, calling\n * `element.click()`, or calling\n * `element.dispatchEvent(new MouseEvent('click', ...))`.\n *\n * Also works around Firefox issue\n * https://bugzilla.mozilla.org/show_bug.cgi?id=1804576 by squelching\n * events for a microtask after called.\n *\n * @example\n * hostClickListener = (event: MouseEvent) {\n *   if (isActivationClick(event)) {\n *     this.dispatchActivationClick(this.buttonElement);\n *   }\n * }\n *\n */\nexport function isActivationClick(event: Event) {\n  // Event must start at the event target.\n  if (event.composedPath()[0] !== event.target) {\n    return false;\n  }\n  // Target must not be disabled; this should only occur for a synthetically\n  // dispatched click.\n  if ((event.target as EventTarget & {disabled: boolean}).disabled) {\n    return false;\n  }\n  // This is an activation if the event should not be squelched.\n  return !squelchEvent(event);\n}\n\n// TODO(https://bugzilla.mozilla.org/show_bug.cgi?id=1804576)\n//  Remove when Firefox bug is addressed.\nfunction squelchEvent(event: Event) {\n  const squelched = isSquelchingEvents;\n  if (squelched) {\n    event.preventDefault();\n    event.stopImmediatePropagation();\n  }\n  squelchEventsForMicrotask();\n  return squelched;\n}\n\n// Ignore events for one microtask only.\nlet isSquelchingEvents = false;\nasync function squelchEventsForMicrotask() {\n  isSquelchingEvents = true;\n  // Need to pause for just one microtask.\n  // tslint:disable-next-line\n  await null;\n  isSquelchingEvents = false;\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}